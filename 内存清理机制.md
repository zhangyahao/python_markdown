## 1. 引用计数（Reference Counting） - 主要机制

### 1.1 基本原理

每个对象都有一个引用计数属性，用于记录指向该对象的引用数量。当引用计数为0时，对象被立即销毁（内存被回收）。

### 1.2 局限性

当使用循环调用时，即使删除了相关变量，但是引用计数不会变为0，无法被引用计数回收，会导致内存泄漏。

### 1.3 循环调用

1. 什么是循环引用
    - list1包含list2，list2又包含list1
    - 形成了引用环，彼此保持对方的引用计数
2. 引用计数无法归零
    - 即使删除了list1和list2变量
    - 两个列表仍互相引用，引用计数各为2
    - 引用计数垃圾回收器无法回收它们

    3. 解决方案
        - python内部清理解决方案：标记-清除
        - 代码层面：使用弱引用
            * 引入**weakref**, `import weakref`
            * 使用weakref来定义对象引用。例如 ：
              ```python
               import weakref
                list1=[]
                list2=[]
                list2.append(weakref.ref(list1))
                list1.append(weakref.ref(list2))
           ```

## 2. 标记-清除（Mark and Sweep） - 解决循环引用

### 2.1 工作原理

1. 标记阶段（Marking）：
    - 从根对象（GC roots）开始遍历
    - 根对象包括：当前栈帧变量、全局变量、模块变量等
    - 标记所有可达对象为"存活"
2. 清除阶段（Sweeping）：

- 遍历堆中所有对象
- 回收所有未标记的对象
- 清除所有对象的标记

## 3. 分代回收

### 3.1 分代原理

分代回收将对象分为三代：

- 0代：新创建的对象
- 1代：经历过一次垃圾回收的对象
- 2代：经历过多次垃圾回收的对象
- 对象越老，越不可能被回收

### 3.2 分代回收配置

```python
import gc

# 查看分代回收阈值
print("当前GC阈值:", gc.get_threshold())
# 默认值：(700, 10, 10)
# 含义：0代对象达到700个触发GC，1代经过10次0代GC后触发，2代经过10次1代GC后触发

# 查看各代统计
print("\n各代对象数量:")
print(gc.get_count())  # (0代对象数, 1代GC次数, 2代GC次数)

# 手动设置阈值
gc.set_threshold(1000, 15, 15)
print(f"\n设置后阈值: {gc.get_threshold()}")

# 禁用/启用垃圾回收
gc.disable()
print(f"GC已禁用: {not gc.isenabled()}")

gc.enable()
print(f"GC已启用: {gc.isenabled()}")
```

## 4. 总结

### 4.1 内存管理原则

1. 优先使用局部变量，函数结束后自动回收
2. 及时删除不再需要的大对象引用
3. 避免不必要的全局变量
4. 使用with语句管理资源
5. 对于缓存，使用弱引用或设置大小限制
6. 定期检查内存使用情况
7. 在生产环境监控GC性能

### 4.2 性能调优建议

1. 调整GC阈值：根据应用特点调整set_threshold()
2. 控制GC时机：在空闲时间手动调用gc.collect()
3. 使用对象池：重用频繁创建销毁的对象
4. 监控GC统计：使用gc.get_stats()分析GC性能
5. 避免频繁创建临时对象：特别是在循环中
